external function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);
external procedure ItemHistHeader(record RcVc);
external procedure PrintItemHistHeader_PerLocation(record RcVc);
external procedure PrintItemHistHeader(record RcVc);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer CostPricePerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer ItemCostPerLocation(record INVc);
external function val CalculateQty2(val,val);
external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);
external function val FindBPPriceBackdated(record CostAccBlock,record INVc,string,val,Date,Boolean);
external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external function Boolean SetInSet2(string,string);
external procedure ItemClassTypef(string,string,var Boolean);
external function val GetStockQty(string,string,Date,Boolean);
external procedure HT2Per(Date, Date , var string);
external procedure HTArtSel(string,string, var string);
external procedure HTDepartments(string,string,var string);
external procedure HTItemHistType(Integer,Integer,Integer,Integer,Integer,Integer,var string);
external procedure HTItemHistType2(Integer,Integer,Integer,Integer,Integer,var string);

procedure ItemHistItemHeader(record RcVc RepSpec,string item,string name,string unittext,val fwdqty,
                             val fwdtotcp,val fwdqty2,var val bal,var Boolean itemheaderf)
begin
  if (itemheaderf==false) then begin
    switch (RepSpec.ArtMode) begin
      case 0: bal = bal + fwdqty;
      case 1: bal = fwdtotcp;
      case 3: bal = bal + fwdqty;
    end;
    if (RepSpec.flags[9]!=0) then begin
      StartFormat(15);
      OutString(0,0,item,false);
      OutString(100,0,name,false);
      OutString(300,0,USetStr(15105),true);// Edit ************************** Wednesday, 20 June 2012 14:19:36
      //OutString(300,0,unittext,false);
      EndFormat;
      Gray_Divider(0,1);
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
          OutString(100,0,USetStr(2492),false);
          OutString(300,0,RepSpec.TransStr,false);
          OutVal(380,0,fwdqty2,M4UVal,true);
          OutVal(410,0,fwdqty,M4UVal,true);
          OutVal(480,0,bal,M4UVal,true);
        case 1:
          OutString(70,0,USetStr(2492),false);
          OutString(220,0,RepSpec.TransStr,false);
          OutVal(300,0,fwdqty,M4UVal,true);
          OutVal(380,0,Round(fwdtotcp/fwdqty,5),M45Val,true);
          OutVal(480,0,fwdtotcp,M45Val,true);
        case 3:
          OutString(100,0,USetStr(2492),false);
          OutString(300,0,RepSpec.TransStr,false);
          OutVal(380,0,fwdqty2,M4UVal,true);
          OutVal(410,0,fwdqty,M4UVal,true);
          OutVal(480,0,bal,M4UVal,true);
      end;
      EndFormat;
    end;  
    itemheaderf = true;
  end;
  return;
end;

procedure ItemHistItemHeader_PerLocation(record RcVc RepSpec,string item,string name,string unittext,val fwdqty,
                         val fwdtotcp,val fwdqty2,var Boolean itemheaderf)
begin
  if (itemheaderf==false) then begin
    if (RepSpec.flags[9]!=0) then begin
      StartFormat(15);
      OutString(15,0,item,false);
      OutString(100,0,name,false);
      OutString(300,0,unittext,false);
      EndFormat;
      Gray_Divider(0,1);
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
          OutString(200,0,USetStr(2492),false);
          OutVal(410,0,fwdqty,M4UVal,true);
          OutVal(480,0,fwdtotcp,M4UVal,true);
        case 1:
          OutString(200,0,USetStr(2492),false);
          OutVal(300,0,fwdqty,M4UVal,true);
          OutVal(380,0,Round(fwdtotcp/fwdqty,5),M45Val,true);
          OutVal(480,0,fwdtotcp,M45Val,true);
      end;
      EndFormat;
    end;  
    itemheaderf = true;
  end;
  return;
end;

procedure PrintItemTotals_Overview(record RcVc RepSpec,record INVc INr,
                                   val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout)
begin
  Boolean testf;
  
  testf = false;
  switch (RepSpec.ArtMode) begin
    case 0:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
        testf = true;
      end;
    case 1:
      if ((itemcpin!=0) or (itemcpout!=0) or (fwdtotcp!=0)) then begin
        testf = true;
      end;
    case 3:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
        testf = true;
      end;
  end;
  if (RepSpec.flags[13]==0) then begin
    if (fwdqty!=0) then begin
      testf = true;
    end;
  end;
  if (testf) then begin
    StartFormat(15);
    OutString(0,0,INr.Code,false);
    OutString(70,0,INr.Name,false);
    switch (RepSpec.ArtMode) begin
      case 0:
        OutVal(240,0,fwdqty,M4Qty,true);
        OutVal(320,0,itemqin,M4Qty,true);
        OutVal(400,0,itemqout,M4Qty,true);
        OutVal(480,0,fwdqty+itemqin+itemqout,M4Qty,true);
      case 1:
        OutVal(240,0,fwdtotcp,M45Val,true); // fwdqty (shows same as fwdtotcp)? fwdcp (is blank)?
        OutVal(320,0,itemcpin,M45Val,true);
        OutVal(400,0,itemcpout,M45Val,true);
        OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M45Val,true);
      case 3:
        OutVal(240,0,fwdqty,M4Qty,true);
        OutVal(320,0,itemqin,M4Qty,true);
        OutVal(400,0,itemqout,M4Qty,true);
        OutVal(480,0,fwdqty+itemqin+itemqout,M4Qty,true);
    end;
    EndFormat;
  end;
  return;
end;

procedure PrintItemTotals_Overview_PerLocation(record RcVc RepSpec,record INVc INr,
                                   val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout)
begin
  Boolean testf;
  
  testf = false;
  switch (RepSpec.ArtMode) begin
    case 0:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
        testf = true;
      end;
    case 1:
      if ((itemcpin!=0) or (itemcpout!=0) or (fwdtotcp!=0)) then begin
        testf = true;
      end;
  end;
  if (RepSpec.flags[13]==0) then begin
    if (fwdqty!=0) then begin
      testf = true;
    end;
  end;
  if (testf) then begin
    if (RepSpec.flags[9]==0) then begin
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
           OutString(15,0,INr.Code,false);
           OutString(90,0,Left(INr.Name,10),false);
           OutVal(240,0,fwdqty,M4UVal,true);
           OutVal(320,0,itemqin,M4UVal,true);
           OutVal(400,0,itemqout,M4UVal,true);
           OutVal(480,0,fwdqty+itemqin+itemqout,M4UVal,true);
        case 1:
           OutString(15,0,INr.Code,false);
           OutString(90,0,Left(INr.Name,20),false);
           OutVal(200,0,fwdqty,M4UVal,true);
           OutVal(240,0,fwdtotcp,M4Val,true);
           OutVal(280,0,itemqin,M4UVal,true);
           OutVal(320,0,itemcpin,M4Val,true);
           OutVal(360,0,itemqout,M4UVal,true);
           OutVal(400,0,itemcpout,M4Val,true);
           OutVal(440,0,fwdqty+itemqin+itemqout,M4Val,true);
           OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M4Val,true);
       end;
      EndFormat;
    end else begin
      Gray_Divider(0,1);
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
          OutString(200,0,INr.Code,false);
          OutVal(480,0,fwdqty+itemqin+itemqout,M4UVal,true);
        case 1:
          OutString(200,0,INr.Code,false);
          OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
          OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M45Val,true);
      end;
      EndFormat;
      Gray_Divider(200,1);
    end;
  end;
  return;
end;

procedure PrintItemTotals_Detailes(record RcVc RepSpec,record INVc INr,Boolean itemheaderf,
                                   val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout,
                                   val itemq2in,val bal)
begin
  if (itemheaderf==true) then begin
    Gray_Divider(0,1);
    StartFormat(15);
    switch (RepSpec.ArtMode) begin
      case 0:
        OutVal(410,0,fwdqty+itemqin+itemqout,M4UVal,true);
        if (RepSpec.flags[12]!=0) then begin
          OutVal(380,0,itemq2in,M45Val,true);
        end;
        OutVal(480,0,bal,M45Val,true);
      case 1:
        OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
        if (RepSpec.flags[12]!=0) then begin
          OutVal(380,0,itemq2in,M45Val,true);
        end;
        OutVal(480,0,Round(fwdtotcp+itemcpin-itemcpout,2),M4Val,true);
      case 3:
        OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
        if (RepSpec.flags[12]!=0) then begin
          OutVal(380,0,itemq2in,M45Val,true);
        end;
        OutVal(480,0,bal,M45Val,true);
    end;
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

procedure PrintItemHist(record RcVc RepSpec,record ItemHistVc IHr,record MainStockBlock MSb,Boolean outf,val bal)
begin
  Integer strid;
  string 50 dblstr;
  Boolean printf;
  record SHVc SHr;// Edit ************************** Wednesday, 20 June 2012 13:15:57
  record PUVc PUr;// Edit ************************** Wednesday, 20 June 2012 13:15:57
  string 2255 vendor;// Edit ************************** Wednesday, 20 June 2012 13:15:58
  
  
  printf = true;
  vendor = "";// Edit ************************** Wednesday, 20 June 2012 13:18:24
  switch (IHr.FileName) begin
    case "IVVc":            
      if (outf) then begin
        strid = 5004;
      end else begin        
        record IVVc IVr;
        
        IVr.SerNr = IHr.TransNr;
        if (ReadFirstMain(IVr,1,true)) then begin end;
        if (IVr.Invalid!=0) then begin
          strid = 5004;
        end else begin
          strid = 5005;
        end;
      end;
      dblstr = "DblIVVc";
    case "IVCashVc":
      if (outf) then begin
        strid = 11675;
      end else begin
        strid = 11675;
      end;
      dblstr = "DblIVCashVc";
    case "INTransferVc": strid = 5040; dblstr = "DblINTransfer";
    case "ProdVc": strid = 5016; dblstr = "DblProd";
    case "ProdOperationVc": strid = 11674; dblstr = "DblProdOperationVc";
    case "PUVc": strid = 5002; dblstr = "DblPU";
                                  // Edit Start ---------------------------------------------- Edit Start
                  //Wednesday, 20 June 2012 13:26:17
                  if(PUr.SerNr!=IHr.TransNr)then begin
                                    PUr.SerNr=IHr.TransNr;
                                    readfirstmain(PUr,1,true);
                                    vendor = PUr.VECode;
                                  end;
                  // Edit End ---------------------------------------------- Edit End
                  
    case "RetPUVc": strid = 5058; dblstr = "DblRetPU";
    case "RetVc": strid = 5029; dblstr = "DblRet";
    case "SDVc": strid = 5020; dblstr = "DblSD";
    case "SRVc": strid = 11676; dblstr = "DblSRVc";
    case "SHVc": strid = 5003; dblstr = "DblSHVc"; 
                                      // Edit Start ---------------------------------------------- Edit Start
                        //Wednesday, 20 June 2012 13:26:09
                        if(SHr.SerNr!=IHr.TransNr)then begin
                                        SHr.SerNr=IHr.TransNr;
                                        readfirstmain(SHr,1,true);
                                        vendor = SHr.CustCode;
                                      end;
                        // Edit End ---------------------------------------------- Edit End
                        
    case "StockMovVc": strid = 5012; dblstr = "DblStockMov";
    case "WSVc": strid = 7650; dblstr = "DblWS";
    case "Fut2ProdOrderInVc": begin
      record ProdOrderVc PrOr;

      PrOr.SerNr = IHr.TransNr;
      if (ReadFirstMain(PrOr,1,true)) then begin end;
      if (PrOr.StatusFlag<3) then begin 
        strid = 5057; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProdOrder";
      end;
    case "Fut2ProdOrderOutVc": begin
      record ProdOrderVc PrOr;

      PrOr.SerNr = IHr.TransNr;
      if (ReadFirstMain(PrOr,1,true)) then begin end;
      if (PrOr.StatusFlag<3) then begin 
        strid = 5057; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProdOrder";
      end;
    case "Fut2ProdInVc": begin
      record ProdVc Prodr;

      Prodr.SerNr = IHr.TransNr;
      if (ReadFirstMain(Prodr,1,true)) then begin end;
      if (Prodr.PRStatusFlag<3) then begin 
        strid = 5037; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProd";
      end;
    case "Fut2ProdOutVc": begin
      record ProdVc Prodr;

      Prodr.SerNr = IHr.TransNr;
      if (ReadFirstMain(Prodr,1,true)) then begin end;
      if (Prodr.PRStatusFlag<3) then begin 
        strid = 5037; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProd";
      end;
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.OKFlag==0) then begin
          strid = 5036; 
        end else begin
          strid = 5038; 
        end;
        dblstr = "DblPOVc";
        if (POr.Closed!=0) then begin
          printf = false;
        end;
      end;
    case "Fut3ORVc": begin
        record ORVc ORr;

        ORr.SerNr = IHr.TransNr;
        if (ReadFirstMain(ORr,1,true)) then begin end;
        if (ORr.Closed!=0) then begin
          printf = false;
        end;
        strid = 5035; 
        dblstr = "DblORVc";
      end;
  end;

  if (printf==false) then begin
    goto LPrintItemHist;
  end;

  switch (RepSpec.ArtMode) begin
    case 0:
      StartFormat(15);
      OutDate(0,0,IHr.TransDate,false);
      OutString(100,0,USetStr(strid),false);
      OutLongInt(200,dblstr,IHr.TransNr,false);
      OutString(270,0,vendor,false);// Edit ************************** Wednesday, 20 June 2012 13:20:55
      OutString(350,0,IHr.Location,false);
      switch (RepSpec.flags[12]) begin
        case 1: OutVal(380,0,IHr.Qty2,M4UVal,true);
        case 2: 
          if (MSb.UnitConvCalc==0) then begin
            OutVal(380,0,IHr.Qty/IHr.Qty2,M45Val,true);
          end else begin
            OutVal(380,0,IHr.Qty2/IHr.Qty,M45Val,true);
          end;
      end;
      OutVal(410,0,IHr.Qty,M4UVal,true);
      OutVal(480,0,bal,M4UVal,true);
      EndFormat;
    case 1:
      StartFormat(15);
      OutDate(0,0,IHr.TransDate,false);
      OutString(70,0,USetStr(strid),false);
      OutLongIntOvst(150,dblstr,IHr.TransNr,false,IHr.Invalid);
      OutString(220,0,IHr.Location,false);
      OutVal(300,0,IHr.Qty,M4UVal,true);
      if (outf) then begin
        OutVal(380,0,Round(bal/IHr.Qty,5),M45Val,true);
      end else begin
        OutVal(380,0,Round(IHr.TotCostPrice/IHr.Qty,5),M45Val,true);
      end;
      OutVal(480,0,Round(bal,4),M45Val,true);//INRS 3
      EndFormat;
    case 3://INRS
      StartFormat(15);
      OutDate(0,0,IHr.TransDate,false);
      OutString(100,0,USetStr(strid),false);
      OutLongInt(200,dblstr,IHr.TransNr,false);
      OutString(300,0,Right(IHr.Variety,len(IHr.Variety)-1),false);
      switch (RepSpec.flags[12]) begin
        case 1: OutVal(380,0,IHr.Qty2,M4UVal,true);
        case 2: 
          if (MSb.UnitConvCalc==0) then begin
            OutVal(380,0,IHr.Qty/IHr.Qty2,M4Qty,true);
          end else begin
            OutVal(380,0,IHr.Qty2/IHr.Qty,M4Qty,true);
          end;
      end;
      OutVal(410,0,IHr.Qty,M4UVal,true);
      OutVal(480,0,bal,M4UVal,true);
      EndFormat;
  end;
LPrintItemHist:;
  return;
end;

procedure PrintItemHist_PerLocation(record RcVc RepSpec,record ItemHistVc IHr,record MainStockBlock MSb,Boolean outf,val bal)
begin
  Integer strid;
  string 50 dblstr;

  switch (IHr.FileName) begin
    case "IVVc": strid = 5004; dblstr = "DblIVVc";
    case "IVCashVc": strid = 11675; dblstr = "DblIVVc";
    case "INTransferVc": strid = 5040; dblstr = "DblINTransfer";
    case "ProdVc": strid = 5016; dblstr = "DblProd";
    case "ProdOperationVc": strid = 11674; dblstr = "DblProdOperationVc";
    case "PUVc": strid = 5002; dblstr = "DblPU";
    case "RetPUVc": strid = 5058; dblstr = "DblRetPU";
    case "RetVc": strid = 5029; dblstr = "DblRet";
    case "SDVc": strid = 5020; dblstr = "DblSD";
    case "SRVc": strid = 11676; dblstr = "DblSRVc";
    case "SHVc": strid = 5003; dblstr = "DblSHVc";
    case "StockMovVc": strid = 5012; dblstr = "DblStockMov";
    case "WSVc": strid = 7650; dblstr = "DblWS";
    case "Fut2ProdOrderInVc": begin
      record ProdOrderVc PrOr;

      PrOr.SerNr = IHr.TransNr;
      if (ReadFirstMain(PrOr,1,true)) then begin end;
      if (PrOr.StatusFlag<3) then begin 
        strid = 5057; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProdOrder";
      end;
    case "Fut2ProdInVc": begin
      record ProdVc Prodr;

      Prodr.SerNr = IHr.TransNr;
      if (ReadFirstMain(Prodr,1,true)) then begin end;
      if (Prodr.PRStatusFlag<3) then begin 
        strid = 5037; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProd";
      end;
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.OKFlag==0) then begin
          strid = 5036; 
        end else begin
          strid = 5038; 
        end;
        dblstr = "DblPOVc";
      end;
    case "Fut3ORVc": strid = 5035; dblstr = "DblORVc";
  end;

  StartFormat(15);
  switch (RepSpec.ArtMode) begin
    case 0:
      OutDate(0,0,IHr.TransDate,false);
      OutString(100,0,USetStr(strid),false);
      OutLongInt(200,dblstr,IHr.TransNr,false);
      OutVal(480,0,IHr.Qty,M4UVal,true);
    case 1:
      OutDate(0,0,IHr.TransDate,false);
      OutString(70,0,USetStr(strid),false);
      OutLongInt(150,dblstr,IHr.TransNr,false);
      OutVal(300,0,IHr.Qty,M4UVal,true);
      if (outf) then begin
        OutVal(400,0,-Round(bal/IHr.Qty,5),M45Val,true);
        OutVal(480,0,-bal,M4Val,true);
      end else begin
        OutVal(400,0,Round(IHr.TotCostPrice/IHr.Qty,5),M45Val,true);
        OutVal(480,0,IHr.TotCostPrice,M4Val,true);
      end;
    case 3://INRS
      OutDate(0,0,IHr.TransDate,false);
      OutString(100,0,USetStr(strid),false);
      OutLongInt(200,dblstr,IHr.TransNr,false);
      OutString(300,0,Right(IHr.Variety,len(IHr.Variety)-1),false);
      switch (RepSpec.flags[12]) begin
        case 1: OutVal(380,0,IHr.Qty2,M4UVal,true);
        case 2: 
          if (MSb.UnitConvCalc==0) then begin
            OutVal(380,0,IHr.Qty/IHr.Qty2,M4Qty,true);
          end else begin
            OutVal(380,0,IHr.Qty2/IHr.Qty,M4Qty,true);
          end;
      end;
      OutVal(410,0,IHr.Qty,M4UVal,true);
      OutVal(480,0,bal,M4UVal,true);
  end;   
  EndFormat;
  return;
end;

procedure PrintReportTotals(record RcVc RepSpec,val SumQFwd,val SumQIn,val SumQOut,val SumCPFwd,val SumCPIn,val SumCPOut,
                            val SumQ2)
begin
  Gray_Divider(0,1);
  switch (RepSpec.flags[9]) begin
    case 0:
      switch (RepSpec.ArtMode) begin
        StartFormat(15);
        case 0:
          OutVal(240,0,SumQFwd,M4Qty,true);
          OutVal(320,0,SumQIn,M4Qty,true);
          OutVal(400,0,SumQOut,M4Qty,true);
          OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
        case 1:
          OutVal(240,0,SumCPFwd,M45Val,true);
          OutVal(320,0,SumCPIn,M45Val,true);
          OutVal(400,0,SumCPOut,M45Val,true);
          OutVal(480,0,SumCPIn-SumCPOut+SumCPFwd,M4Qty,true);
        case 3:
          OutVal(240,0,SumQFwd,M4Qty,true);
          OutVal(320,0,SumQIn,M4Qty,true);
          OutVal(400,0,SumQOut,M4Qty,true);
          OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
      end;
      EndFormat;
    case 1:
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
          if (RepSpec.flags[12]!=0) then begin
            OutVal(380,0,SumQ2,M4Qty,true);
          end;
          OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
        case 1:
          OutVal(300,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
          OutVal(480,0,SumCPIn-SumCPOut+SumCPFwd,M45Val,true);
        case 3:
          if (RepSpec.flags[12]!=0) then begin
            OutVal(380,0,SumQ2,M4Qty,true);
          end;
          OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
      end;
      EndFormat;
  end; 
  Gray_Divider(0,1);
  return;
end;

procedure ItemHistList_In(record RcVc RepSpec,record ItemHistVc IHr,record INVc INr,record MainStockBlock MSb,                         
                          record CostAccBlock CAb,var Boolean itemheaderf,
                          val fwdqty,val fwdtotcp,val fwdqty2,
                          var val itemqin,var val itemcpin,var val itemq2in,var val bal)
begin
  val t,q2;
  val cp;
  Boolean testf;

  testf = true;
  switch (IHr.FileName) begin
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.Closed!=0) then begin
          testf = false;
        end;
      end;
    case "Fut3ORVc": begin
        record ORVc ORr;

        ORr.SerNr = IHr.TransNr;
        if (ReadFirstMain(ORr,1,true)) then begin end;
        if (ORr.Closed!=0) then begin
          testf = false;
        end;
      end;
  end;

  if (testf) then begin    
    if (RepSpec.flags[15]==0) then begin
      ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
    end else begin
      ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
    end;
    itemqin = itemqin + IHr.Qty;
    itemq2in = itemq2in + IHr.Qty2;
    cp = IHr.TotCostPrice;    
    itemcpin = itemcpin + cp;
    if (RepSpec.flags[9]==1) then begin      
      switch (RepSpec.ArtMode) begin
        case 0: bal = bal + IHr.Qty;
        case 1: bal = cp;
        case 3: bal = bal + IHr.Qty;
      end;
      if (RepSpec.flags[15]!=0) then begin
        PrintItemHist_PerLocation(RepSpec,IHr,MSb,false,bal);
      end else begin
        PrintItemHist(RepSpec,IHr,MSb,false,bal);
      end;
    end;
  end;
  return;
end;

procedure ItemHistList_Out(record RcVc RepSpec,record ItemHistVc IHr,record INVc INr,record MainStockBlock MSb,                         
                          record CostAccBlock CAb,var Boolean itemheaderf,
                          val fwdqty,val fwdtotcp,val fwdqty2,
                          var val itemqout,var val itemcpout,var val itemq2out,var val bal)
begin
  val t,q2;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  val cp;
  Boolean testf;
    
  testf = true;
  switch (IHr.FileName) begin
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.Closed!=0) then begin
          testf = false;
        end;
      end;
    case "Fut3ORVc": begin
        record ORVc ORr;

        ORr.SerNr = IHr.TransNr;
        if (ReadFirstMain(ORr,1,true)) then begin end;
        if (ORr.Closed!=0) then begin
          testf = false;
        end;
      end;
  end;
  if (testf==false) then begin
    goto LItemHistList_Out;
  end;
  GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);  
  if (RepSpec.flags[15]==0) then begin
    ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
  end else begin
    ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
  end;
  itemqout = itemqout + IHr.Qty;
  itemq2out = itemq2out + IHr.Qty2;
  cp = IHr.TotCostPrice;
// If we take these lines out, Item History will be correct with WA decimal round offs.
// But is it correct? I mean, it then shows exactly the amount that was taken out. I think it IS correct
//
  if (IHr.FileName!="RetPUVc") then begin
    if (queuecostmodel!=20) then begin
      switch (primary) begin
        case 9: cp = 0;
        case 1:
  /*      
          if (CAb.CostPricePerLocation!=0) then begin
            cp = IHr.CPTotCostPerLoc;
          end else begin
            cp = IHr.CPTotCost;
          end;
  */      
          cp = IHr.CPTotCost / INr.PriceFactor;
        case 2:
          cp = IHr.BPTotCost;
        case 3:
          if (WAPerLocation(INr,ITr,CAb)!=0) then begin
            if (IHr.WATotCostPerLoc!=0) then begin
              cp = IHr.WATotCostPerLoc;
            end;
          end else begin
            if (IHr.WATotCost!=0) then begin
              cp = IHr.WATotCost;
            end;
          end;
//          cp = IHr.TotCostPrice;//vg -  fix round off for WA
      end;
    end;
  end;
//
  itemcpout = itemcpout + cp;

  if (RepSpec.flags[9]==1) then begin      
    switch (RepSpec.ArtMode) begin
      case 0: bal = bal + IHr.Qty;
      case 1: bal = -cp;
      case 3: bal = bal + IHr.Qty;
    end;
    if (RepSpec.flags[15]!=0) then begin
      PrintItemHist_PerLocation(RepSpec,IHr,MSb,true,bal);
    end else begin
      PrintItemHist(RepSpec,IHr,MSb,true,bal);
    end;
  end;
LItemHistList_Out:;  
  return;
end;

procedure ItemForwardBalance(record RcVc RepSpec,record INVc INr,var val fwdqty,var val fwdtotcp,var val fwdcp,string mainstock)
begin
  record LocationVc Locr;
  Boolean locfound,nostockf;
  val tq,tv;
  record CostAccBlock CAb;
  Date dt;
  Integer primary,queuecostmodel;
  record ITVc ITr;

  BlockLoad(CAb);
  fwdqty = blankval;
  fwdtotcp = blankval;
  fwdcp = blankval;
  if (INr.ItemType!=0) then begin
    dt = AddDay(RepSpec.sStartDate,-1);
    fwdqty = GetStockQty(INr.Code,RepSpec.TransStr,dt,false);
    if (RepSpec.ArtMode==1) then begin
      GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
      switch (primary) begin
        case 1: fwdtotcp = FindCPPriceBackdated(CostPricePerLocation(INr,ITr,CAb),INr,RepSpec.TransStr,fwdqty,dt,false) * fwdqty;
        case 2: fwdtotcp = FindBPPriceBackdated(CAb,INr,RepSpec.TransStr,fwdqty,dt,false) * fwdqty;
        case 3: fwdtotcp = FindWAPriceBackdated(WAPerLocation(INr,ITr,CAb),INr,RepSpec.TransStr,fwdqty,dt,false,0);
        case 4: 
          if (ItemCostPerLocation(INr)!=0) then begin
            if (blank(RepSpec.TransStr)) then begin
              fwdqty = blankval;
              Locr.Code = "";
              nostockf = true;
              locfound = true;
              while (LoopMain(Locr,1,locfound)) begin
                if (locfound) and (nonblank(Locr.Code)) then begin
                  tq = GetStockQty(INr.Code,Locr.Code,dt,false);
                  switch (queuecostmodel) begin
                    case 0: tv = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,0,dt,false,0,false,0,0,0);
                    case 1: tv = FindCostPriceLIFOBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,dt,false,0,false,0,0,0);
//                    case 20: tv = FindCostPriceSerialNumberBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,0,dt,false,0,false,0,0);
                    case 20: tv = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,0,dt,false,0,false,0,0,0);
                  end;
                  fwdtotcp = fwdtotcp + tv;
                  fwdqty = fwdqty + tq;
                  nostockf = false;
                end;
              end;
              if (blank(mainstock)) and (nostockf) then begin
                fwdqty = GetStockQty(INr.Code,"",dt,false); 
              end;
            end else begin
              switch (queuecostmodel) begin
                case 0: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
                case 1: fwdtotcp = FindCostPriceLIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,dt,false,0,false,0,0,0);
//                case 20: fwdtotcp = FindCostPriceSerialNumberBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0);
                case 20: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
              end;
            end;
          end else begin
            switch (queuecostmodel) begin
              case 0: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
              case 1: fwdtotcp = FindCostPriceLIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,dt,false,0,false,0,0,0);
//              case 20: fwdtotcp = FindCostPriceSerialNumberBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0);
              case 20: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
            end;
          end;
          fwdcp = fwdtotcp/fwdqty;
      end;
    end;
  end;
  return;
end;

procedure AddItemHistRecord(record ItemHistVc IHr,record ItemHistVc sumIHr)
begin
  sumIHr.Qty = sumIHr.Qty + IHr.Qty;
  sumIHr.Qty2 = sumIHr.Qty2 + IHr.Qty2;
  sumIHr.TotCostPrice = sumIHr.TotCostPrice + IHr.TotCostPrice;
  sumIHr.WATotCost = sumIHr.WATotCost + IHr.WATotCost;
  sumIHr.CPTotCost = sumIHr.CPTotCost + IHr.CPTotCost;
  sumIHr.BPTotCost = sumIHr.BPTotCost + IHr.BPTotCost;

  sumIHr.WATotCostPerLoc = sumIHr.WATotCostPerLoc + IHr.WATotCostPerLoc;
  sumIHr.CPTotCostPerLoc = sumIHr.CPTotCostPerLoc + IHr.CPTotCostPerLoc;
  sumIHr.BPTotCostPerLoc = sumIHr.BPTotCostPerLoc + IHr.BPTotCostPerLoc;
  return;
end;

procedure PrintItemHistoryRecord(record RcVc RepSpec,record ItemHistVc sumIHr,record INVc INr,record MainStockBlock MSb,
                              record CostAccBlock CAb,var Boolean itemheaderf,
                              val fwdqty,val fwdtotcp,val fwdqty2,
                              var val itemqin,var val itemcpin,var val itemq2in,
                              var val itemqout,var val itemcpout,var val itemq2out,
                              var val bal)
begin
  switch (sumIHr.FileName) begin
    case "Fut2ProdOrderInVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut2ProdOrderOutVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut2ProdInVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut2ProdOutVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut1POVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut3ORVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;
    case "IVVc":
      if (RepSpec.flags[1]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;      
    case "IVCashVc":
      if (RepSpec.flags[1]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;      
    case "INTransferVc": 
      if (RepSpec.flags[17]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;
    case "ProdVc": 
      if (RepSpec.flags[5]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;
    case "ProdOperationVc": 
      if (RepSpec.flags[20]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;
    case "PUVc": 
      if (RepSpec.flags[3]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "RetPUVc": 
      if (RepSpec.flags[19]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
    case "RetVc": 
      if (RepSpec.flags[8]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;      
    case "SDVc": 
      if (RepSpec.flags[6]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
    case "SRVc":
      if (RepSpec.flags[1]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;      
    case "SHVc": 
      if (RepSpec.flags[2]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
    case "StockMovVc": 
      if (RepSpec.flags[4]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;
    case "WSVc": 
      if (RepSpec.flags[7]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
  end;         
  return;
end;

procedure SumTotals(val fwdqty,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout,val itemq2in,
                    var val SumQFwd,var val SumCPFwd,var val SumQIn,var val SumQOut,var val SumCPIn,var val SumCPOut,var val SumQ2)
begin
  SumQFwd = SumQFwd + fwdqty;
  SumCPFwd = SumCPFwd + Round(fwdtotcp,2);
  SumQIn = SumQIn + itemqin;
  SumQOut = SumQOut + itemqout;
  SumCPIn = SumCPIn + Round(itemcpin,2);
  SumCPOut = SumCPOut + Round(itemcpout,2);
  SumQ2 = SumQ2 + itemq2in;
  return;
end;

procedure SetBlankVals(var val fwdqty,var val fwdqty2,var val fwdcp,var val fwdtotcp,var val itemqin,var val itemqout,
                       var val itemq2out,var val itemcpin,var val itemcpout,var val itemq2in,var val bal)
begin
  fwdqty = blankval;
  fwdqty2 = blankval;
  fwdcp = blankval;
  fwdtotcp = blankval;
  itemqin = blankval;
  itemqout = blankval;
  itemq2out = blankval;
  itemcpin = blankval;
  itemcpout = blankval;
  itemq2in = blankval;
  bal = blankval;      
  return;
end;

function Boolean SignEqual(val Qty1,val Qty2)
begin
  Boolean res;
  
  res = false;
  if (Qty1<0) then begin
    if (Qty2<0) then begin
      res = true;
    end;
  end else begin
    if (Qty2>=0) then begin
      res = true;
    end;
  end;
  SignEqual = res;
  return;
end;

function Boolean CheckIfAnyHistory(record RcVc RepSpec,record INVc INr)
begin
  Boolean res;
  record ItemHistVc IHr;
  Integer sorting,ihkeys;
  string 255 ihckey;
  Boolean foundIH,testf;
  
  sorting = RepSpec.flags[10];
  ResetLoop(IHr);
  switch (sorting) begin
    case 0:
      if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0)  then begin
        ihkeys = 2;
        ihckey = "ArtCodeFD";
      end else begin
        ihkeys = 3;
        ihckey = "ArtCodeLocFD";
        IHr.Location = RepSpec.TransStr;
      end;
    case 1:
      if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0) then begin
        ihkeys = 2;
        ihckey = "ArtCode";
      end else begin
        ihkeys = 3;
        ihckey = "ArtCodeLoc";
        IHr.Location = RepSpec.TransStr;
      end;
  end;
  IHr.ArtCode = INr.Code;
  switch (sorting) begin
    case 0: IHr.FIFODate = RepSpec.sStartDate;
    case 1: IHr.TransDate = RepSpec.sStartDate;
  end;
  foundIH = true;
  while (LoopKey(ihckey,IHr,ihkeys,foundIH)) begin
    if (IHr.ArtCode!=INr.Code) then begin foundIH = false; end;
    switch (sorting) begin
      case 0: if (IHr.FIFODate>RepSpec.sEndDate) then begin foundIH = false; end;
      case 1: if (IHr.TransDate>RepSpec.sEndDate) then begin foundIH = false; end;
    end;
    testf = true;
    if (nonblank(RepSpec.TransStr)) then begin
      if (ihkeys==3) then begin
        if (RepSpec.TransStr!=IHr.Location) then begin foundIH = false; end;
      end else begin
        if (RepSpec.TransStr!=IHr.Location) then begin testf = false; end;
      end;
    end; 
    if (RepSpec.flags[11]!=0) then begin
      if (INr.ItemType!=1) then begin testf = false; end;
    end;
    if (RepSpec.flags[14]!=0) then begin
      if (IHr.StockAffectf==0) then begin 
        if (Left(IHr.FileName,3)!="Fut") then begin
          testf = false;
        end;
      end;
    end else begin
      if (IHr.StockAffectf==0) then begin testf = false; end;
    end;
    if (foundIH==false) then begin testf = false; end;
    if (testf) then begin
      res = true;
      foundIH = false;
    end;
  end;
  CheckIfAnyHistory = res;
  return;
end;

procedure INrsRnRun(record RcVc RepSpec,record MainStockBlock MSb,record CostAccBlock CAb,
                    var val SumQFwd,var val SumQIn,var val SumQOut,var val SumCPFwd,var val SumCPIn,var val SumCPOut,var val SumQ2)
begin
  string 20 frin,toin;
  string 20 frloc,toloc;
  string 255 ckey,ihckey;
  Integer keys,ihkeys,sorting;
  record INVc INr;
  record PIVc PIr;
  record ItemHistVc IHr;
  record ItemHistVc sumIHr;
  record ItemHistVc lastIHr;
  Boolean foundIH,foundIN,testf,itemheaderf,ihtestf;  
  val itemqin,itemq2in,itemqout,bal,itemcpin,itemcpout,itemq2out;
  val fwdqty,fwdqty2,fwdcp,fwdtotcp;
    
  sorting = RepSpec.flags[10];
  frin = FirstInRange(RepSpec.f1,20);
  toin = LastInRange(RepSpec.f1,20);
  frloc = FirstInRange(RepSpec.AccStr,20);
  toloc = LastInRange(RepSpec.AccStr,20);
  if (nonblank(RepSpec.f3)) then begin
    INr.Group = RepSpec.f3;
    INr.Code = frin;
    ckey = "Group";
    keys = 2;
  end else begin
    INr.Code = frin;
    ckey = "Code";
    keys = 1;
  end;
  foundIN = true;
  while (LoopKey(ckey,INr,keys,foundIN)) begin
    if (foundIN) then begin
      if (nonblank(toin)) then  begin
        if (INr.Code>toin) then begin foundIN = false; end;
      end;  
    end;
    if (foundIN) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group!=RepSpec.f3) then begin foundIN = false; end;
      end;  
    end;
    if (foundIN) then begin
      if (RepSpec.flags[11]==1) then begin
        if (INr.ItemType!=1) then begin
          goto LINwhileend;
        end;
      end;    
      if (nonblank(toloc)) then begin
        if (INr.Department>toloc) then begin goto LINwhileend; end;
      end;  
      if (nonblank(frloc)) then begin
        if (INr.Department<frloc) then begin goto LINwhileend; end;
      end;  
      if (nonblank(RepSpec.f2)) then begin
        PIr.DefaultChoice = 1;
        PIr.ItemCode = INr.Code;
        PIr.VECode = RepSpec.f2;
        if (ReadFirstKey("DefaultChoice",PIr,3,true)==false) then begin
          goto LINwhileend;
        end;
      end;
      if (nonblank(RepSpec.f4)) then begin
        if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
          goto LINwhileend;
        end;
      end;
      if (nonblank(RepSpec.f5)) then begin
        testf = false;
        ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
        if (testf==false) then begin
          goto LINwhileend;
        end;
      end;
    end;
    if (foundIN) then begin
      SetBlankVals(fwdqty,fwdqty2,fwdcp,fwdtotcp,itemqin,itemqout,itemq2out,itemcpin,itemcpout,itemq2in,bal);
      itemheaderf = false;
      ItemForwardBalance(RepSpec,INr,fwdqty,fwdtotcp,fwdcp,MSb.MainStock);
      if (RepSpec.flags[13]!=0) then begin
        if (fwdqty!=0) then begin
          if (RepSpec.flags[15]==0) then begin
            ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
          end else begin
            ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
          end;
        end;
      end else begin
        if (fwdqty!=0) then begin
          if (RepSpec.flags[15]==0) then begin
            ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
          end else begin
            ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
          end;
        /*what was this for ? 
          if (CheckIfAnyHistory(RepSpec,INr)==false) then begin
            fwdqty = blankval;
            fwdtotcp = blankval;
            fwdcp = blankval;
          end;
        */
        end;
      end;

      ResetLoop(IHr);
      switch (sorting) begin
        case 0:
          if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0)  then begin
            ihkeys = 2;
            ihckey = "ArtCodeFD";
          end else begin
            ihkeys = 3;
            ihckey = "ArtCodeLocFD";
            IHr.Location = RepSpec.TransStr;
          end;
        case 1:
          if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0) then begin
            ihkeys = 2;
            ihckey = "ArtCode";
          end else begin
            ihkeys = 3;
            ihckey = "ArtCodeLoc";
            IHr.Location = RepSpec.TransStr;
          end;
      end;
      IHr.ArtCode = INr.Code;
      switch (sorting) begin
        case 0: IHr.FIFODate = RepSpec.sStartDate;
        case 1: IHr.TransDate = RepSpec.sStartDate;
      end;
      RecordNew(lastIHr);
      RecordNew(sumIHr);
      foundIH = true;
      while (LoopKey(ihckey,IHr,ihkeys,foundIH)) begin
        if (IHr.ArtCode!=INr.Code) then begin foundIH = false; end;
        switch (sorting) begin
          case 0: if (IHr.FIFODate>RepSpec.sEndDate) then begin foundIH = false; end;
          case 1: if (IHr.TransDate>RepSpec.sEndDate) then begin foundIH = false; end;
        end;
        testf = true;
        if (nonblank(RepSpec.TransStr)) then begin
          if (ihkeys==3) then begin
            if (RepSpec.TransStr!=IHr.Location) then begin foundIH = false; end;
          end else begin
            if (RepSpec.TransStr!=IHr.Location) then begin testf = false; end;
          end;
        end; 
        if (RepSpec.flags[14]!=0) then begin
          if (IHr.StockAffectf==0) then begin 
            if (Left(IHr.FileName,3)!="Fut") then begin
              testf = false;
            end;
          end;
        end else begin
          if (RepSpec.flags[11]==0) then begin
            if (INr.ItemType==1) then begin 
              if (IHr.StockAffectf==0) then begin testf = false; end;
            end;
          end else begin
            if (IHr.StockAffectf==0) then begin testf = false; end;
          end;
        end;
        if (foundIH==false) then begin testf = false; end;
//StopAlert("IHr.FileName " & IHr.FileName & " IHr.TransNr " & IHr.TransNr & " IHr.Location " & IHr.Location & " foundIH " & foundIH);
        if (testf) then begin
          if (lastIHr.SerNr<=0) then begin//first time
            RecordCopy(sumIHr,IHr);
          end else begin
            ihtestf = true;
            if (lastIHr.FileName==IHr.FileName) and (lastIHr.TransNr==IHr.TransNr) and (lastIHr.Row==IHr.Row) and (SignEqual(lastIHr.Qty,IHr.Qty)) then begin
              ihtestf = false;
            end;
//StopAlert("lastIHr.FileName " & lastIHr.FileName & " lastIHr.Qty " & lastIHr.Qty & " IHr.Qty " & IHr.Qty & " ihtestf " & ihtestf);
            if (ihtestf) then begin
              PrintItemHistoryRecord(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,itemqout,itemcpout,itemq2out,bal);
              RecordCopy(sumIHr,IHr);
            end else begin
              AddItemHistRecord(IHr,sumIHr);
            end;
          end;
          RecordCopy(lastIHr,IHr);
        end;
      end;
      if (sumIHr.Qty!=0) then begin
        PrintItemHistoryRecord(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,itemqout,itemcpout,itemq2out,bal);
      end;
      SumTotals(fwdqty,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout,itemq2in,SumQFwd,SumCPFwd,SumQIn,SumQOut,SumCPIn,SumCPOut,SumQ2);
      if (RepSpec.flags[15]==0) then begin
        switch (RepSpec.flags[9]) begin
          case 0: PrintItemTotals_Overview(RepSpec,INr,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout);
          case 1: PrintItemTotals_Detailes(RepSpec,INr,itemheaderf,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout,itemq2in,bal);
        end;
      end else begin
        PrintItemTotals_Overview_PerLocation(RepSpec,INr,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout);
      end;
    end;    
LINwhileend:;  
  end;
  return;
end;

procedure PrintLocation(record LocationVc Locr)
begin
  StartFormat(15);
   OutString(0,0,Locr.Code,false);
   OutString(100,0,Locr.Name,false);
  EndFormat;
  Gray_Divider(0,200);
  return;
end;

procedure PrintLocationTotals(record RcVc RepSpec,string location,val LocSumQFwd,val LocSumCPFwd,val LocSumQIn,val LocSumQOut,val LocSumCPIn,val LocSumCPOut,val LocSumQ2)
begin
  if (RepSpec.flags[9]==0) then begin
    Gray_Divider(150,1);
    StartFormat(15);
    switch (RepSpec.ArtMode) begin
      case 0:
         OutString(100,0,location,false);
         OutVal(240,0,LocSumQFwd,M4UVal,true);
         OutVal(320,0,LocSumQIn,M4UVal,true);
         OutVal(400,0,LocSumQOut,M4UVal,true);
         OutVal(480,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
      case 1:
         OutString(60,0,location,false);
         OutVal(200,0,LocSumQFwd,M4UVal,true);
         OutVal(240,0,LocSumCPFwd,M4Val,true);
         OutVal(280,0,LocSumQIn,M4UVal,true);
         OutVal(320,0,LocSumCPIn,M4Val,true);
         OutVal(360,0,LocSumQOut,M4UVal,true);
         OutVal(400,0,LocSumCPOut,M4Val,true);
         OutVal(440,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4Val,true);
         OutVal(480,0,LocSumCPFwd+LocSumCPIn-LocSumCPOut,M4Val,true);
    end;
    EndFormat;
  end else begin
    Gray_Divider(300,1);
    StartFormat(15);
    switch (RepSpec.ArtMode) begin
      case 0:
         OutString(250,0,location,false);
         OutVal(1,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
      case 1:
         OutString(200,0,location,false);
         OutVal(300,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
         OutVal(480,0,LocSumCPFwd+LocSumCPIn-LocSumCPOut,M4Val,true);
    end;
    EndFormat;
    Gray_Divider(0,1);
    StartFormat(5);
    EndFormat;
  end;
  return;
end;

procedure SetSumBlankVals(var val LFwd,var val LCPFwd,var val LQIn,var val LQOut,var val LCPIn,var val LCPOut,var val LQ2)
begin
  LFwd = blankval;
  LCPFwd = blankval;
  LQIn = blankval;
  LQOut = blankval;
  LCPIn = blankval;
  LCPOut = blankval;
  LQ2 = blankval;
  return;
end;

global
procedure INrsRn(record RcVc RepSpec)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  record LocationVc Locr;
  Boolean found;
  string 255 frloc,toloc;
  val SumQIn,SumQOut,SumQFwd,SumCPIn,SumCPOut,SumCPFwd,SumQ2;
  val bal;
  val LocSumQIn,LocSumQOut,LocSumQFwd,LocSumCPIn,LocSumCPOut,LocSumCPFwd,LocSumQ2;

  frloc = FirstInRange(RepSpec.f6,20);
  toloc = LastInRange(RepSpec.f6,20);
  BlockLoad(MSb);
  BlockLoad(CAb);
  ItemHistHeader(RepSpec);
  Gray_Divider(0,1);
  switch (RepSpec.flags[15]) begin
    case 0: 
      if (frloc!=toloc) then begin
        StartFormat(15);
         OutString(0,0,USetStr(11687),false);
        EndFormat;
        goto LINrsRn;
      end;
      RepSpec.TransStr = frloc;
      INrsRnRun(RepSpec,MSb,CAb,SumQFwd,SumQIn,SumQOut,SumCPFwd,SumCPIn,SumCPOut,SumQ2);
      PrintReportTotals(RepSpec,SumQFwd,SumQIn,SumQOut,SumCPFwd,SumCPIn,SumCPOut,SumQ2);
    case 1:
      found = true;
      Locr.Code = frloc;
      while (LoopMain(Locr,1,found)) begin
        if (nonblank(RepSpec.f6)) then begin
          if (Locr.Code>toloc) then begin found = false; end;
        end;
        if (found) then begin
          SetSumBlankVals(LocSumQFwd,LocSumCPFwd,LocSumQIn,LocSumQOut,LocSumCPIn,LocSumCPOut,LocSumQ2);
          PrintLocation(Locr);
          RepSpec.TransStr = Locr.Code;          
          INrsRnRun(RepSpec,MSb,CAb,LocSumQFwd,LocSumQIn,LocSumQOut,LocSumCPFwd,LocSumCPIn,LocSumCPOut,LocSumQ2);
          PrintLocationTotals(RepSpec,Locr.Code,LocSumQFwd,LocSumCPFwd,LocSumQIn,LocSumQOut,LocSumCPIn,LocSumCPOut,LocSumQ2);
          SumTotals(LocSumQFwd,LocSumCPFwd,LocSumQIn,LocSumQOut,LocSumCPIn,LocSumCPOut,LocSumQ2,SumQFwd,SumCPFwd,SumQIn,SumQOut,SumCPIn,SumCPOut,SumQ2);
        end;
      end;
      RepSpec.TransStr = "";
      PrintLocationTotals(RepSpec,"",SumQFwd,SumCPFwd,SumQIn,SumQOut,SumCPIn,SumCPOut,SumQ2);
  end;  
LINrsRn:;  
  EndJob; 
  return;
end;
