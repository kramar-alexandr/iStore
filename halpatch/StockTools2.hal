external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function val FindCostPriceWA(Integer,record INVc,string);
external updating procedure DeleteBatchBestBefore(string,string);
external procedure PUCalcPerc(val,string,var val);
external function Integer ArtCodeWAPerLocation(string);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external function val FindCostPrice_ReturnedGoods_FromSH(record INVc,record RetVc,row RetVc,Integer);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external procedure CalcNewPrice(val,string,var val);
external function val FindCostPrice_ReturnedGoods(record RetVc,row RetVc);
external procedure RetSumUp(var record RetVc);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external function Boolean GetCuAccUseRow(string,var row CuAccBlock);
external function Boolean TestArtCode(string,string,record INVc);
external procedure RetPUSumUp(var record RetPUVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function val MulRateToBase2(var string,val,val,val,val,val,val,Integer);
external procedure Base1ToBase2(var val,Date,var val);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external updating procedure UpdateLocationWeightedAv(string,string,val,val,val,val,Boolean);
external updating procedure UpdateLocationWeightedAv2(string,string,val,val,val,val);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external updating procedure UpdateSVOSerStock(string,string,string,string,string,val,val,Date,Date,val,string);
external updating procedure UpdateSVOSerHist(string,string,string,LongInt,Date,string,string);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external updating procedure UpdateSerStock(string,string,string,val,val);
external function Boolean ShouldItemUpdateStock(string);

global
updating procedure InvalidatePU(record PUVc PUr)
begin
  /* duplicated in PurUpdateOvst
  
  record MainStockBlock MainStockRec;
  record ItemHistVc IHr;
  record ItemHistVc oldIHr;
  Integer i,rwcnt;
  row PUVc PUrw;
  string 10 location;
  string 10 thelocation;
  val t,t2,q2;
  
  if (PUr.Invalid==0) then begin
    goto LInvalidatePU;
  end;
  location = PUr.Location;
  BlockLoad(MainStockRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if (blank(PUrw.Location)) then begin
      thelocation = location;
    end else begin
      thelocation = PUrw.Location;
    end;
    IHr.FileName = "PUVc";
    IHr.TransNr = PUr.SerNr;
    IHr.Row = i;
    if (ReadFirstKey("FNTransNr",IHr,3,true)) begin
      RecordCopy(oldIHr,IHr);
      IHr.RemQty = 0;
      IHr.StockAffectf = 0;
      if (RecordUpdate(oldIHr,IHr,true)==0) then begin end;
      
      if (nonblank(PUrw.SerialNr)) then begin
        if ((nonblankdate(PUrw.BestBefore)) or (PUrw.UnitXval!=0)) then begin
          DeleteBatchBestBefore(PUrw.ArtCode,PUrw.SerialNr);
        end;
      end;
      UpdateSerStock(PUrw.ArtCode,thelocation,PUrw.SerialNr,-PUrw.Quant,-PUrw.CostPrice);
      t2 = -PUrw.Quant;
      if (MainStockRec.UnitConvCalc==0) then begin
        q2 = t2*PUrw.Coefficient;
      end else begin
        q2 = t2/PUrw.Coefficient;
      end;
      UpdateInstock("PUVc",PUr.SerNr,PUrw.ArtCode,thelocation,PUr.TransDate,t2,t,t,t,t,q2,t,t,t);
    end;
  end;
  */
LInvalidatePU:;
  return;
end;

procedure CalculateStockMovRowFIFO(record CostAccBlock CostAccRec,string frlocation,record StockMovVc SMp,row StockMovVc StockMovrw,Integer currow,
                                   Boolean fillsentf,Boolean fillrcvf)
BEGIN
  val adjstockv,t;
  row StockMovVc StockMovrw2;
  Integer j;
  string 255 fromlocation;
  record INVc INr;

  if (fillsentf) then begin
    if (StockMovrw.SentQuant!=0) then begin
      if (ReadFirstItem(StockMovrw.ArtCode,INr,true,false)) then begin end;
      adjstockv = blankval;
      for (j=0;j<currow;j=j+1) begin
        MatRowGet(SMp,j,StockMovrw2);
        if (TestArtCode(StockMovrw2.ArtCode,StockMovrw.ArtCode,INr)) then begin
          adjstockv = adjstockv + StockMovrw2.SentQuant;
        end;
      end;
      StockMovrw.SentFIFORowVal = FindCostPrice(StockMovrw.ArtCode,frlocation,StockMovrw.SerialNr,StockMovrw.SentQuant,adjstockv,false);
      StockMovrw.SentFIFORowVal = Round(StockMovrw.SentFIFORowVal,5);
      StockMovrw.SentOldPrice = StockMovrw.SentFIFORowVal/StockMovrw.SentQuant;      
      CalcNewPrice(StockMovrw.SentOldPrice,StockMovrw.SentExtraSCost,t);
      StockMovrw.SentNewPrice = t;
    end;
  end;
  
  if (fillrcvf) then begin
    fromlocation = frlocation;
    if (nonblank(SMp.ThrouLocation)) then begin
      fromlocation = SMp.ThrouLocation;
    end;
    if (ReadFirstItem(StockMovrw.ArtCode,INr,true,false)) then begin end;
    adjstockv = blankval;
    for (j=0;j<currow;j=j+1) begin
      MatRowGet(SMp,j,StockMovrw2);
      if (TestArtCode(StockMovrw2.ArtCode,StockMovrw.ArtCode,INr)) then begin
        adjstockv = adjstockv + StockMovrw2.Quant;  
      end;
    end;    
    StockMovrw.FIFORowVal = FindCostPrice(StockMovrw.ArtCode,fromlocation,StockMovrw.SerialNr,StockMovrw.Quant,adjstockv,false);
    StockMovrw.FIFORowVal = Round(StockMovrw.FIFORowVal,5);
    StockMovrw.OldPrice = StockMovrw.FIFORowVal/StockMovrw.Quant;      
    CalcNewPrice(StockMovrw.OldPrice,StockMovrw.ExtraSCost,t);
    StockMovrw.NewPrice = t;
  end;
  RETURN;
END;

global
procedure UpdateStockMovFIFO(var record StockMovVc SMp,record StockMovVc prevSMp,Integer stat)
BEGIN
  Integer i,j,rwcnt;
  row StockMovVc StockMovrw, StockMovrw2;
  val t,adjstockv;
  string 10 curcode;
  val fr,to1,to2,br1,br2;
  record CostAccBlock CostAccRec;
  record MainStockBlock MainStockRec;
  Boolean fillsentf,fillrcvf;
          
  BlockLoad(CostAccRec);
  BlockLoad(MainStockRec);
  SMp.CurncyCode = ""; // Need to switch to base currency when autofilling FIFO
  GetFullCurncyRate(curcode,SMp.TransDate,fr,to1,to2,br1,br2);
  SMp.CurncyCode = curcode;
  SMp.FrRate = fr;
  SMp.ToRateB1 = to1; 
  SMp.ToRateB2 = to2;
  SMp.BaseRate1 = br1;
  SMp.BaseRate2 = br2;

  if (nonblank(SMp.ThrouLocation)) then begin
    fillsentf = true;
    fillrcvf = true;
  end else begin
    fillrcvf = true;
  end;
  if (SMp.OKFlag!=0) then begin
    fillrcvf = true;
    if (stat==2) then begin  
      if (RecordValid(prevSMp)) then begin
        if (prevSMp.OKFlag!=0) then begin
          fillrcvf = false;
        end;
      end;
    end;
  end;
  if (SMp.SentOKFlag!=0) then begin
    fillsentf = true;
    if (stat==2) then begin  
      if (RecordValid(prevSMp)) then begin
        if (prevSMp.SentOKFlag!=0) then begin
          fillsentf = false;
        end;
      end;
    end;
  end;
//StopAlert("fillsentf " & fillsentf  & " fillrcvf " & fillrcvf);
  
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    CalculateStockMovRowFIFO(CostAccRec,SMp.FrLocation,SMp,StockMovrw,i,fillsentf,fillrcvf);
    MatRowPut(SMp,i,StockMovrw);
  end;
LUpdateStockMovFIFO:;
  RETURN;
END;

global
procedure CalculateWSRowFIFO(record MainStockBlock MSb,string location,record WSVc WSp,row WSVc WSrw,Integer currow)
BEGIN
  val adjstockv;
  row WSVc WS2rw;
  Integer j;
  record INVc INr;

  if (ReadFirstItem(WSrw.ArtCode,INr,true,false)) then begin end;
  adjstockv = blankval;
  for (j=0;j<currow;j=j+1) begin    
    MatRowGet(WSp,j,WS2rw);
    if (TestArtCode(WS2rw.ArtCode,WSrw.ArtCode,INr)) then begin
      adjstockv = adjstockv + WS2rw.Quant;
    end;
  end;
  WSrw.FIFORowVal = FindCostPrice(WSrw.ArtCode,location,WSrw.SerialNr,WSrw.Quant,adjstockv,false);
  WSrw.FIFORowVal = Round(WSrw.FIFORowVal,5);
  WSrw.FIFO = WSrw.FIFORowVal/WSrw.Quant;
  WSrw.FIFO = Round(WSrw.FIFO,5);
  RETURN;
END;

global
procedure WSUpdateFIFO(record WSVc WSp)
BEGIN
  record MainStockBlock MSb;
  record CostAccBlock CostAccRec;
  row WSVc WSrw;
  Integer i,rwcnt;
  string 10 location;
  
  BlockLoad(CostAccRec);
  location = WSp.Location;
  if (blank(location)) then begin
    BlockLoad(MSb);
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    if (nonblank(WSrw.ArtCode)) then begin
      if (WSrw.Quant!=0) then begin//INRS strcuture
        CalculateWSRowFIFO(MSb,location,WSp,WSrw,i);
        MatRowPut(WSp,i,WSrw);
      end;
    end;
  end;
  RETURN;
END;

global
procedure CalculateRetPURowFIFO(record CostAccBlock CostAccRec,string location,record RetPUVc RetPUp,row RetPUVc RetPUrw,Integer currow)
BEGIN
  val adjstockv;
  row RetPUVc RetPU2rw;
  Integer j;
  record INVc INr;

  if (ReadFirstItem(RetPUrw.ArtCode,INr,true,false)) then begin end;
  adjstockv = blankval;
  for (j=0;j<currow;j=j+1) begin    
    MatRowGet(RetPUp,j,RetPU2rw);
    if (TestArtCode(RetPU2rw.ArtCode,RetPUrw.ArtCode,INr)) then begin
      adjstockv = adjstockv + RetPU2rw.Quant;
    end;
  end;
  RetPUrw.FIFORowVal = FindCostPrice(RetPUrw.ArtCode,location,RetPUrw.SerialNr,RetPUrw.Quant,adjstockv,false);
  RetPUrw.FIFORowVal = Round(RetPUrw.FIFORowVal,5);
  RetPUrw.FIFO = RetPUrw.FIFORowVal/RetPUrw.Quant;
  RetPUrw.FIFO = Round(RetPUrw.FIFO,5);
  RETURN;
END;

global
procedure RetPUUpdateFIFO(var record RetPUVc RetPUp)
BEGIN
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  row RetPUVc RetPUrw;
  Integer i,rwcnt;
  string 10 location;
  
  BlockLoad(CAb);
  if (CAb.RetPUCostPriceNotFromPU==0) then begin
    rwcnt = MatRowCnt(RetPUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(RetPUp,i,RetPUrw);
      if (nonblank(RetPUrw.ArtCode)) then begin
        if (RetPUrw.Quant!=0) and (RetPUrw.FIFO==0) then begin
          location = RetPUrw.Location;
          if (blank(location)) then begin
            location = RetPUp.Location;
          end;
          if (blank(location)) then begin
            BlockLoad(MSb);
            location = MSb.MainStock;
          end;
          CalculateRetPURowFIFO(CAb,location,RetPUp,RetPUrw,i);
          MatRowPut(RetPUp,i,RetPUrw);
        end;
      end;
    end;
    RetPUSumUp(RetPUp);
  end;
  RETURN;
END;

global
procedure CalculateRetRowFIFO(record CostAccBlock CAb,string location,record RetVc Retp,row RetVc Retrw,Integer currow)
begin
  val adjstockv;
  row RetVc Ret2rw;
  Integer j;
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel,waperloc;

  if (ReadFirstItem(Retrw.ArtCode,INr,true,false)) then begin end;
  GetCostModel(INr,CAb,ITr,primary,queuecostmodel,true);
  if (INr.ItemType==0) or (INr.ItemType==3) then begin
  end else begin
    waperloc = WAPerLocation(INr,ITr,CAb);
  end;
  
  adjstockv = blankval;
  for (j=0;j<currow;j=j+1) begin    
    MatRowGet(Retp,j,Ret2rw);
    if (TestArtCode(Ret2rw.ArtCode,Retrw.ArtCode,INr)) then begin
      adjstockv = adjstockv + Ret2rw.Quant;
    end;
  end;
//rememebr about PasteSHInRet when changing this
  if (CAb.RetCostPriceFromSH!=0) then begin 
    switch (primary) begin
      case 0:
        Retrw.CostPrice = blankval;
      case 1: 
        Retrw.CostPrice = INr.InPrice;
      otherwise
        Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(INr,Retp,Retrw,currow);
    end;
  end else begin
    switch (primary) begin
      case 0:
        Retrw.CostPrice = blankval;
      case 1:
//from delivery
      case 2:
        Retrw.CostPrice = FindCostPriceBasePrice(CAb,INr,ITr);
      case 3:
        Retrw.CostPrice = FindCostPriceWA(waperloc,INr,location);
//WA per location ignored here        
      case 4: 
//from delivery
      case 9:
        switch (queuecostmodel) begin
          case 20:
//from delivery
          otherwise
            Retrw.CostPrice = blankval;
        end;
      otherwise
        Retrw.CostPrice = FindCostPrice_ReturnedGoods(Retp,Retrw)/Retrw.Quant;
    end;
  end;
  Retrw.CostPrice = Round(Retrw.CostPrice,5);
  Retrw.UPrice = Retrw.CostPrice;
  Retrw.UPrice = Round(Retrw.UPrice,5);
  Retrw.BasePrice = INr.InPrice;
  return;
end;

global
procedure RetUpdateFIFO(var record RetVc Retp)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  row RetVc Retrw;
  Integer i,rwcnt;
  string 10 location;
  Boolean testf;
  
  BlockLoad(CAb);
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (nonblank(Retrw.ArtCode)) then begin
      location = Retrw.Location;
      if (blank(location)) then begin
        location = Retp.Location;
      end;
      if (blank(location)) then begin
        BlockLoad(MSb);
        location = MSb.MainStock;
      end;
      testf = true;
      if (Retrw.Quant==0) then begin
        testf = false;
      end;
      if (CAb.RetCostPriceFromSH==0) then begin 
        if (Retrw.UPrice!=0) then begin
//          testf = false;
//always fill, since things might change, like Location....
        end;
      end;
      if (testf) then begin
        CalculateRetRowFIFO(CAb,location,Retp,Retrw,i);
        MatRowPut(Retp,i,Retrw);
      end;
    end;
  end;
  RetSumUp(Retp);
  RETURN;
END;

global
updating procedure OffHireUpdateSVO(record OffHireVc OffHirer)
begin
  record MainStockBlock MainStockRec;
  row OffHireVc OffHirerw;
  Integer i,rwcnt;
  val t,t2,q2;
  string 10 location,loc2;
  string 200 cucode,name;
  
  location = OffHirer.Location;
  BlockLoad(MainStockRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(OffHirer);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OffHirer,i,OffHirerw);
    if (nonblank(OffHirerw.Location)) then begin
      loc2 = OffHirerw.Location;
    end else begin
      loc2 = location;
    end;
    if (nonblank(OffHirerw.ArtCode)) then begin
      if (MainStockRec.updateSVGM!=0) then begin
        t = OffHirerw.Quant;
        if (OffHirer.AgreementNr>0) then begin
          cucode = "";
          name = USetStr(11760);
        end else begin
          cucode = OffHirer.CustCode;
          name = OffHirer.Addr0;
        end;
        UpdateSVOSerStock(OffHirerw.ArtCode,OffHirerw.Spec,OffHirerw.SerialNr,cucode,name,
                          OffHirerw.Cost,OffHirerw.Value,OffHirerw.PurchaseDate,OffHirerw.WarrantyUntil,t,OffHirerw.VECode);
        UpdateSVOSerHist(OffHirerw.ArtCode,OffHirerw.SerialNr,"OffHireVc",OffHirer.SerNr,OffHirer.TransDate,OffHirer.CustCode,OffHirerw.VECode);
      end;
    end;
  end;
  return;
end;

global
updating procedure DispatchUpdateSVO(record DispatchVc Dispatchr)
begin
  record MainStockBlock MainStockRec;
  row DispatchVc Dispatchrw;
  Integer i,rwcnt;
  val t,t2,q2;
  Date bld;
  string 10 location;
  
  location = Dispatchr.Location;
  BlockLoad(MainStockRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(Dispatchr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Dispatchr,i,Dispatchrw);
    if (nonblank(Dispatchrw.ArtCode)) then begin
      if (MainStockRec.updateSVGM!=0) then begin
        t = -Dispatchrw.Quant;
        UpdateSVOSerStock(Dispatchrw.ArtCode,Dispatchrw.Spec,Dispatchrw.SerialNr,Dispatchr.CustCode,Dispatchr.Addr0,
                          BlankVal,BlankVal,bld,bld,t,"");
        UpdateSVOSerHist(Dispatchrw.ArtCode,Dispatchrw.SerialNr,"DispatchVc",Dispatchr.SerNr,Dispatchr.TransDate,Dispatchr.CustCode,"");
      end;
    end;
  end;
  return;
end;

procedure ArtCodeOnThisRet(Integer cnt,record RetVc Retp,string artcode,record INVc INr,var val resp)
BEGIN
  row RetVc Retrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(Retp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (TestArtCode(Retrw.ArtCode,artcode,INr)) then begin
      resp = resp + Retrw.Quant;
    end;  
  end;
  RETURN;
END;

global
updating procedure RetUpdateCostPrice(record RetVc Retp)
BEGIN
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row RetVc Retrw;
  row RetVc Ret2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,qonrec,trs,trsb2,startq;
  record RoundBlock RoundRec;
  record CostAccBlock CostAccRec;
  record BaseCurBlock BCb;
  string 255 location;
  
  BlockLoad(CostAccRec);    
  if (CostAccRec.UpdWeightAvFromRet==0) then begin
    goto LRetUpdateCostPrice;
  end;
  BlockLoad(RoundRec);    
  BlockLoad(BCb);    
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (Retrw.Quant!=0) then begin
      if (ReadFirstItem(Retrw.ArtCode,INr,false,false)) then begin
        RecordCopy(oldINr,INr);
        rs = Retrw.CostPrice;

        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(rs,Retp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock - Retrw.Quant;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(Retp,j,Ret2rw);
          if (TestArtCode(Ret2rw.ArtCode,Retrw.ArtCode,INr)) then begin
            q = q - Ret2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        startq = q;

        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
//          rs = rs*INr.PriceFactor;
//this is sick isnt it ? at least causing WA be not same as NL transaction from Ret , and what is someone changes this afterwads ? shouldnt we use Ret value always? 
//but maybe calc cost price when editng Ret ? 
        end;
        q = q + Retrw.Quant;
        if (q!=0) then begin
          t2 = Retrw.Quant*rs;
          t = t + t2;
          trs = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;

        q = startq;
        t = q*INr.WeighedAvPriceB2;
        if (INr.PriceFactor!=0) then begin
//this is sick isnt it ? at least causing WA be not same as NL transaction from Ret , and what is someone changes this afterwads ? shouldnt we use Ret value always? 
//but maybe calc cost price when editng Ret ? 
//          rsb2 = rsb2*INr.PriceFactor;
        end;
        q = q + Retrw.Quant;
        if (q!=0) then begin
          t2 = Retrw.Quant*rsb2;
          t = t + t2;
          trsb2 = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisRet(i+1,Retp,Retrw.ArtCode,INr,qonrec);

        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(Retrw.CostPrice,Retp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        location = Retrw.Location;
        if (blank(location)) then begin
          location = Retp.Location;
        end;
        UpdateLocationWeightedAv(INr.Code,location,Retrw.Quant,Retrw.CostPrice,rsb2,qonrec,false);
        if ((Retrw.Quant!=0) and (INr.ItemType==1)) then begin//CostPrice
          switch (INr.UpdateCost) begin
            case 2:
              if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
          end;
          INr.WeighedAvPrice = Round(INr.WeighedAvPrice,RoundRec.RndFIFO);
          INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,RoundRec.RndFIFO);
          switch(INr.UpdateCost) begin
            case 0:;
            otherwise
              INr.InPrice = Round(INr.InPrice,RoundRec.RndFIFO);
              INr.InPriceB2 = Round(INr.InPriceB2,RoundRec.RndFIFO);
              INr.LastPriceChange = CurrentDate;
          end;
          if (RecordUpdate(oldINr,INr,false)==0) then begin end;
        end;
      end;
    end;
  end;
LRetUpdateCostPrice:;  
  RETURN;
END;

procedure ArtCodeOnThisIV(Integer cnt,record IVVc IVp,string artcode,record INVc INr,var val resp)
begin
  row IVVc IVrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(IVp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (TestArtCode(IVrw.ArtCode,artcode,INr)) then begin
      resp = resp + IVrw.Quant;
    end;  
  end;
  return;
end;

global
updating procedure IVUpdateCostPrice(record IVVc IVp)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row IVVc IVrw;
  row IVVc IV2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,qonrec,trs,trsb2,startq;
  record RoundBlock RoundRec;
  record CostAccBlock CostAccRec;
  Boolean testf;
  string 255 location;
  
  BlockLoad(RoundRec);    
  BlockLoad(CostAccRec);    
  if (CostAccRec.UpdWeightAvFromRet==0) then begin
    goto LIVUpdateCostPrice;
  end;
  if (IVp.InvType!=3) then begin
    if (IVp.Invalid==0) then begin
      goto LIVUpdateCostPrice;
    end;
  end;
  if (IVp.UpdStockFlag==0) then begin
    goto LIVUpdateCostPrice;
  end;
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    testf = true;
    if (IVrw.stp!=1) then begin testf = false; end;
    if (IVrw.Quant<=0) then begin testf = false; end;
    if (IVp.OrderNr>0) then begin 
      if (IVrw.OrdRow>=0) then begin testf = false; end;
    end;
    if (testf) then begin
      if (ReadFirstItem(IVrw.ArtCode,INr,false,false)) then begin
        RecordCopy(oldINr,INr);
        rs = IVrw.FIFORowVal/IVrw.Quant;
        Base1ToBase2(rs,IVp.TransDate,rsb2);
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock - IVrw.Quant;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(IVp,j,IV2rw);
          if (TestArtCode(IV2rw.ArtCode,IVrw.ArtCode,INr)) then begin
            q = q - IV2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        startq = q;

        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rs = rs*INr.PriceFactor;
        end;
        q = q + IVrw.Quant;
        if (q!=0) then begin
          t2 = IVrw.Quant*rs;
          t = t + t2;
          trs = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;

        q = startq;
        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rsb2 = rsb2*INr.PriceFactor;
        end;
        q = q + IVrw.Quant;
        if (q!=0) then begin
          t2 = IVrw.Quant*rsb2;
          t = t + t2;
          trsb2 = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisIV(i+1,IVp,IVrw.ArtCode,INr,qonrec);
        rs = IVrw.FIFORowVal/IVrw.Quant;
        Base1ToBase2(rs,IVp.TransDate,rsb2);
        location = IVrw.Location;
        if (blank(location)) then begin
          location = IVp.Location;
        end;
        UpdateLocationWeightedAv(INr.Code,location,IVrw.Quant,IVrw.FIFORowVal/IVrw.Quant,rsb2,qonrec,false);
        if ((IVrw.Quant!=0) and (INr.ItemType==1)) then begin//CostPrice
          switch (INr.UpdateCost) begin
            case 2:
              if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
          end;
          INr.WeighedAvPrice = Round(INr.WeighedAvPrice,RoundRec.RndFIFO);
          INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,RoundRec.RndFIFO);
          switch(INr.UpdateCost) begin
            case 0:;
            otherwise
              INr.InPrice = Round(INr.InPrice,RoundRec.RndFIFO);
              INr.InPriceB2 = Round(INr.InPriceB2,RoundRec.RndFIFO);
              INr.LastPriceChange = CurrentDate;
          end;
          if (RecordUpdate(oldINr,INr,false)==0) then begin end;
        end;
      end;
    end;
  end;
LIVUpdateCostPrice:;  
  RETURN;
END;

procedure ArtCodeOnThisStockMov(Integer cnt,record StockMovVc StockMovp,string artcode,record INVc INr,var val resp,Boolean sendf)
BEGIN
  row StockMovVc StockMovrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(StockMovp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(StockMovp,i,StockMovrw);
    if (TestArtCode(StockMovrw.ArtCode,artcode,INr)) then begin
      if (sendf) then begin 
        resp = resp + StockMovrw.SentQuant;
      end else begin
        resp = resp + StockMovrw.Quant;
      end;
    end;  
  end;
  RETURN;
END;

global
updating procedure StockMovUpdateCostPrice(record StockMovVc SMp,record StockMovVc prevSMp)
BEGIN
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row StockMovVc SMrw;
  row StockMovVc SM2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,trs,trsb2,qonrec;
  val rswaperloc,rswaperlocb2;
  record RoundBlock RoundRec;
  Boolean updatewithsendf,updatef;
  val startwa,startwab2;
  
  BlockLoad(RoundRec);     
  if (SMp.OKFlag!=0) then begin
    updatef = true;
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.OKFlag!=0) then begin
        updatef = false;
      end;
    end;
  end;

  if (SMp.SentOKFlag!=0) then begin
    updatewithsendf = true;
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.SentOKFlag!=0) then begin
        updatewithsendf = false;
      end;
    end;
  end;
  if (updatef==false) and (updatewithsendf==false) then begin goto LStockMovUpdateCostPrice; end;
  
  
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,SMrw);
    if (updatewithsendf) then begin
    if (SMrw.SentQuant!=0) then begin
      found = ReadFirstItem(SMrw.ArtCode,INr,false,true);
      RecordCopy(oldINr,INr);
      if (found) then begin
        switch (INr.UpdateCost) begin
          otherwise//WA always
            if (ArtCodeWAPerLocation(INr.Code)) then begin 
              if (startwa==0) then begin
                startwa = INr.WeighedAvPrice;
              end;
              if (startwab2==0) then begin
                startwab2 = INr.WeighedAvPriceB2;
              end;
              rs = startwa;              
              if (nonblank(SMrw.SentExtraSCost)) then begin
                PUCalcPerc(rs,SMrw.SentExtraSCost,t);
                rs = rs + t;            
              end;
              rswaperloc = SMrw.SentNewPrice;
            end else begin
              rs = SMrw.SentNewPrice;
            end;
            rsb2 = MulRateToBase2(SMp.CurncyCode,rs,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            rswaperlocb2 = MulRateToBase2(SMp.CurncyCode,rswaperloc,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            FindStockValue(INr.Code,"",ISr);
            q = ISr.Instock - SMrw.SentQuant;
            qonrec = 0;
            for (j=i+1;j<rwcnt;j=j+1) begin
              MatRowGet(SMp,j,SM2rw);
              if (TestArtCode(SM2rw.ArtCode,SMrw.ArtCode,INr)) then begin
        			  qonrec = qonrec + SM2rw.SentQuant;
              end;
            end;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPrice;            
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;

              rswaperloc = rswaperloc*INr.PriceFactor;
              rswaperlocb2 = rswaperlocb2*INr.PriceFactor;
            end;            
            t2 = rs*SMrw.SentQuant;
            t = t + t2;
            q = q + SMrw.SentQuant;
            trs = t/q;
            if (q>=0) then begin
              INr.WeighedAvPrice = trs;
            end;

            q = ISr.Instock - SMrw.SentQuant;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPriceB2;
            t2 = rsb2*SMrw.SentQuant;
            t = t + t2;
            q = q + SMrw.SentQuant;
            trsb2 = t/q;
            if (q>=0) then begin
              INr.WeighedAvPriceB2 = trsb2;
            end;
            
            ArtCodeOnThisStockMov(i+1,SMp,SMrw.ArtCode,INr,qonrec,true);            
            UpdateLocationWeightedAv(INr.Code,SMp.ThrouLocation,SMrw.SentQuant,rswaperloc,rswaperlocb2,qonrec,false);
            found = false;
            if (nonblank(SMrw.SentExtraSCost)) then begin
              INr.WeighedAvPrice = Round(INr.WeighedAvPrice,RoundRec.RndFIFO);         
              INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,RoundRec.RndFIFO);         
              if (RecordUpdate(oldINr,INr,false)==0) then begin end;
            end;
        end;
      end;
    end;
    end;
    if (updatef) then begin
    if (SMrw.Quant!=0) then begin
      found = ReadFirstItem(SMrw.ArtCode,INr,false,true);
      RecordCopy(oldINr,INr);
      if (found) then begin
        switch (INr.UpdateCost) begin
          otherwise//WA always
            if (ArtCodeWAPerLocation(INr.Code)) then begin 
              if (startwa==0) then begin
                startwa = INr.WeighedAvPrice;
              end;
              if (startwab2==0) then begin
                startwab2 = INr.WeighedAvPriceB2;
              end;
              rs = startwa;              
              if (nonblank(SMrw.ExtraSCost)) then begin
                PUCalcPerc(rs,SMrw.ExtraSCost,t);
                rs = rs + t;            
              end;
              rswaperloc = SMrw.NewPrice;
            end else begin
              rs = SMrw.NewPrice;
            end;
            rsb2 = MulRateToBase2(SMp.CurncyCode,rs,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            rswaperlocb2 = MulRateToBase2(SMp.CurncyCode,rswaperloc,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            FindStockValue(INr.Code,"",ISr);
            q = ISr.Instock - SMrw.Quant;
            qonrec = 0;
            for (j=i+1;j<rwcnt;j=j+1) begin
              MatRowGet(SMp,j,SM2rw);
              if (TestArtCode(SM2rw.ArtCode,SMrw.ArtCode,INr)) then begin
        			  qonrec = qonrec + SM2rw.Quant;
              end;
            end;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPrice;
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
            t2 = rs*SMrw.Quant;
            t = t + t2;
            q = q + SMrw.Quant;
            trs = t/q;
            INr.WeighedAvPrice = trs;

            q = ISr.Instock - SMrw.Quant;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPriceB2;
            t2 = rsb2*SMrw.Quant;
            t = t + t2;
            q = q + SMrw.Quant;
            trsb2 = t/q;
            INr.WeighedAvPriceB2 = trsb2;
            ArtCodeOnThisStockMov(i+1,SMp,SMrw.ArtCode,INr,qonrec,false);            
            UpdateLocationWeightedAv(INr.Code,SMp.ToLocation,SMrw.Quant,rswaperloc,rswaperlocb2,qonrec,false);
            found = false;
            if (nonblank(SMrw.ExtraSCost)) then begin
/*      Elar ?      
              switch (INr.UpdateCost) begin
                case 2:
                  if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                    INr.InPrice = INr.WeighedAvPrice;
                    INr.LastPriceChange = CurrentDate;
                  end;
                  if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                    INr.InPriceB2 = INr.WeighedAvPriceB2;
                  end;
              end;
*/              
              INr.WeighedAvPrice = Round(INr.WeighedAvPrice,RoundRec.RndFIFO);         
              INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,RoundRec.RndFIFO);         
/*              
              switch(INr.UpdateCost) begin
                case 0:;
                otherwise
                  INr.InPrice = Round(INr.InPrice,RoundRec.RndFIFO);
                  INr.InPriceB2 = Round(INr.InPriceB2,RoundRec.RndFIFO);
                  INr.LastPriceChange = CurrentDate;
              end;
*/              
              if (RecordUpdate(oldINr,INr,false)==0) then begin end;
            end;
        end;
      end;
    end;
    end;
  end;
LStockMovUpdateCostPrice:;  
  RETURN;
END;

procedure ArtCodeOnThisLateCost(Integer cnt,record LateCostVc LateCostp,string artcode,record INVc INr,var val resp)
BEGIN
  row LateCostVc LateCostrw;
  Integer rwcnt,i;


  resp = blankval;
  rwcnt = MatRowCnt(LateCostp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(LateCostp,i,LateCostrw);
    if (TestArtCode(LateCostrw.ArtCode,artcode,INr)) then begin
      resp = resp + LateCostrw.Quant;
    end;
  end;
  RETURN;
END;

global
updating procedure LateCostUpdateCostPrice(record LateCostVc LateCostp)
BEGIN
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row LateCostVc LateCostrw;
  row LateCostVc LateCost2rw;
  Integer j,rwcnt,i;
  val rs,rsb2,t,t2,q,trs,trsb2,qonrec;
  Date curdate;
  record RoundBlock RoundRec;
  
  if ((LateCostp.OKFlag==1) and (LateCostp.Invalid==0)) then begin
    BlockLoad(RoundRec);
    curdate = CurrentDate;
    rwcnt = MatRowCnt(LateCostp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LateCostp,i,LateCostrw);
      if ((LateCostrw.stp==3) or (LateCostrw.ovst!=0)) then begin
        goto LSKIPLateCostROW;
      end;
      if (LateCostrw.Quant!=0) then begin
      if (ReadFirstItem(LateCostrw.ArtCode,INr,false,false)) then begin
        RecordCopy(oldINr,INr);
//      CopyM4Val(&INr.LastLateCostrchPrice,&rs);
        INr.LastPurchPrice2 = LateCostrw.UPrice;
        INr.LastPurchPrice = LateCostrw.CostPrice;
        INr.LastPurchCurncyCode = LateCostp.CurncyCode;          
        rs = LateCostrw.CostPrice;
        Base1ToBase2(rs,LateCostp.TransDate,rsb2);
        
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock - LateCostrw.Quant;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(LateCostp,j,LateCost2rw);
          if (TestArtCode(LateCost2rw.ArtCode,LateCostrw.ArtCode,INr)) then begin
            q = q - LateCost2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rs = rs*INr.PriceFactor;
        end;
        q = q + LateCostrw.Quant;
        if (q!=0) then begin
          t2 = LateCostrw.Quant*rs;
          t = t + t2;
          trs = t/q;
        end;
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;
        t = q*INr.WeighedAvPriceB2;
        if (INr.PriceFactor!=0) then begin
          rsb2 = rsb2*INr.PriceFactor;
        end;
        q = q + LateCostrw.Quant;
        if (q!=0) then begin
          t2 = LateCostrw.Quant*rsb2;
          t = t + t2;
          trsb2 = t/q;
        end;
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisLateCost(i+1,LateCostp,LateCostrw.ArtCode,INr,qonrec);          
        UpdateLocationWeightedAv(INr.Code,LateCostp.Location,LateCostrw.Quant,rs,rsb2,qonrec,false);
        switch (INr.UpdateCost) begin
          case 1:
            rs = LateCostrw.CostPrice;
            if (INr.PriceFactor!=0) then begin            
              rs = rs*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
              INr.LastPriceChange = curdate;
            end;
          case 2:
            if (INr.InPrice!=INr.WeighedAvPrice) then begin  // inprice has changed 
              INr.InPrice = INr.WeighedAvPrice;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin  // inprice has changed 
              INr.InPriceB2 = INr.WeighedAvPriceB2;
            end;
          case 3:
            rs = LateCostrw.UPrice;
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
            end;
        end;
        INr.WeighedAvPrice = Round(INr.WeighedAvPrice,RoundRec.RndFIFO);
        INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,RoundRec.RndFIFO);
        switch(INr.UpdateCost) begin
          case 0:;
          otherwise
            INr.InPrice = Round(INr.InPrice,RoundRec.RndFIFO);
            INr.InPriceB2 = Round(INr.InPriceB2,RoundRec.RndFIFO);
            INr.LastPriceChange = CurrentDate;
        end;
        if (RecordUpdate(oldINr,INr,false)==0) then begin
        end;
      end;
      end;
LSKIPLateCostROW:;      
    end;    
  end;
  RETURN;
END;

procedure ArtCodeOnThisRetPU(Integer cnt,record RetPUVc RetPUp,string artcode,record INVc INr,var val resp)
BEGIN
  row RetPUVc RetPUrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(RetPUp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    if (TestArtCode(RetPUrw.ArtCode,artcode,INr)) then begin
      resp = resp + RetPUrw.Quant;
    end;  
  end;
  RETURN;
END;

global
updating procedure RetPUUpdateCostPrice(record RetPUVc RetPUp)
BEGIN
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row RetPUVc RetPUrw;
  row RetPUVc RetPU2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,qonrec,trs,trsb2;
  record RoundBlock RoundRec;
  record CostAccBlock CostAccRec;
  record BaseCurBlock BCb;
  string 255 location;
  
  BlockLoad(RoundRec);    
  BlockLoad(CostAccRec);    
  BlockLoad(BCb);    
  if (CostAccRec.UpdWeightAvFromRetPU==0) then begin
    goto LRetPUUpdateCostPrice;
  end;
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(RetPUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    if (RetPUrw.Quant!=0) then begin
      if (ReadFirstItem(RetPUrw.ArtCode,INr,false,false)) then begin
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock;
        
//        ArtCodeOnThisRetPU(i+1,RetPUp,RetPUrw.ArtCode,INr,qonrec);//totally not correct
//        q = q - qonrec;        

        qonrec = 0;
        for (j=0;j<i;j=j+1) begin
          MatRowGet(RetPUp,j,RetPU2rw);
          if (TestArtCode(RetPU2rw.ArtCode,RetPUrw.ArtCode,INr)) then begin
            qonrec = qonrec + RetPU2rw.Quant;
          end;
        end;
        q = ISr.Instock - qonrec;
        RecordCopy(oldINr,INr);
        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(rs,RetPUp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        trs = q*INr.WeighedAvPrice; 
        if (INr.PriceFactor!=0) then begin
          trs = trs*INr.PriceFactor;
        end;        
        t = RetPUrw.Quant*RetPUrw.FIFO;
        if (INr.PriceFactor!=0) then begin
          t = t*INr.PriceFactor;
        end;        
        trs = trs - t;
        q = q - RetPUrw.Quant;
        trs = trs/q;
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;
        
        q = ISr.Instock - qonrec;
        trsb2 = q*INr.WeighedAvPriceB2;
        if (INr.PriceFactor!=0) then begin
          trsb2 = trsb2*INr.PriceFactor;
        end;       
         
        t = RetPUrw.Quant*RetPUrw.FIFO;
        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(t,RetPUp.TransDate,t);
        end else begin
          t = blankval;
        end;
        if (INr.PriceFactor!=0) then begin
          t = t*INr.PriceFactor;
        end;        
        trsb2 = trsb2 - t;
        q = q - RetPUrw.Quant;
        trsb2 = trsb2/q;        
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(RetPUrw.FIFO,RetPUp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        location = RetPUrw.Location;
        if (blank(location)) then begin
          location = RetPUp.Location;
        end;
        UpdateLocationWeightedAv2(INr.Code,location,RetPUrw.Quant,RetPUrw.FIFO,rsb2,qonrec);
        if ((RetPUrw.Quant!=0) and (INr.ItemType==1)) then begin//FIFO
          switch (INr.UpdateCost) begin
            case 2:
              if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
          end;
          if (qonrec<=0) then begin
            INr.WeighedAvPrice = Round(INr.WeighedAvPrice,RoundRec.RndFIFO);
            INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,RoundRec.RndFIFO);
//otherwise no rounding, more precise WA            
          end;
          switch(INr.UpdateCost) begin
            case 0:;
            otherwise
              INr.InPrice = Round(INr.InPrice,RoundRec.RndFIFO);
              INr.InPriceB2 = Round(INr.InPriceB2,RoundRec.RndFIFO);
              INr.LastPriceChange = CurrentDate;
          end;
          if (RecordUpdate(oldINr,INr,false)==0) then begin end;
        end;
      end;
    end;
  end;
LRetPUUpdateCostPrice:;  
  RETURN;
END;

global
updating procedure UpdateLocOKNr(string loc,var val LocOKNrp)
BEGIN
  record LocationVc Locr;
  record MainStockBlock MainStockRec;
  
  if (LocOKNrp!=0) then begin
//    goto LUpdateLocOKNr;
  end;
  BlockLoad(MainStockRec);
  switch (MainStockRec.Chronology) begin
    case 0:
      LocOKNrp = blankval;
      MainStockRec.LastOKNr = MainStockRec.LastOKNr + 1;
      LocOKNrp = MainStockRec.LastOKNr;
      BlockStore(MainStockRec);
    case 1:
      Locr.Code = loc;
      if (blank(Locr.Code)) then begin
        Locr.Code = MainStockRec.MainStock;
      end;
      if (ReadFirstMain(Locr,1,true)) then begin
        Locr.LastOKNr = Locr.LastOKNr + 1;
        LocOKNrp = Locr.LastOKNr;
        if (RecordStore(Locr,true)) then begin
        end;;
      end else begin
        MainStockRec.LastOKNr = MainStockRec.LastOKNr + 1;
        LocOKNrp = MainStockRec.LastOKNr;
        BlockStore(MainStockRec);
      end;   
    case 2: 
      MainStockRec.LastOKNr = MainStockRec.LastOKNr + 1;
      LocOKNrp = MainStockRec.LastOKNr;
      BlockStore(MainStockRec);
  end;
LUpdateLocOKNr:;  
  RETURN;
END;

global
function Boolean GetCuAccUseRow2(string cuacc,var row CuAccBlock rescuaccrw)
BEGIN
  record CuAccVc CuAccr;
  string 60 objstr;
  Boolean res;

  CuAccr.Code = cuacc;
  if (ReadFirstMain(CuAccr,1,true)) then begin
    objstr = CuAccr.Objects;
  end;  
  if (GetCuAccUseRow(objstr,rescuaccrw)) then begin res = true; end;
  GetCuAccUseRow2 = res;
  RETURN;
END;

procedure GetLocationFromOrder(record ORVc ORr,LongInt OrdRow,string mainstock,var string ordlocation,var val qty,var val ordqty)
BEGIN
  row ORVc ORrw;
  Integer i,rwcnt;

  ordqty = blankval;
  qty = blankval;
  ordlocation = "";
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (OrdRow==i) then begin
      ordlocation = ORrw.Location;
      qty = ORrw.Quant - ORrw.Shipd1;
      if (ORr.Closed==0) then begin      
        ordqty = ORrw.Quant;
      end;
      goto LGetLocationFromOrder;
    end;
  end;
LGetLocationFromOrder:;
  if (blank(ordlocation)) then begin
    ordlocation = ORr.Location;
  end;  
  if (blank(ordlocation)) then begin
    ordlocation = mainstock;
  end;  
  RETURN;
END;

global
updating procedure RetUpdateStock(record RetVc Retp,Boolean removef,Boolean rebuildstockf)
BEGIN
  record INVc INr;
  row RetVc Retrw;
  record MainStockBlock MSb;
  string 255 location;
  string 10 ordlocation;
  Integer i,rwcnt;
  val t,orq,qty,q2,tmp,ordqty,rsrved;
  record ORVc ORr;
  Boolean orfound,closedf;
  record SHVc RecSHr;
  row SHVc RecSHrw;
  Boolean isstruct;
  Integer j,shrwcnt;

  BlockLoad(MSb);
  closedf = false;
  ORr.SerNr = Retp.OrdNr;
  orfound = ReadFirstMain(ORr,1,true);
  if (orfound) then begin
    if (ORr.Closed!=0) then begin
      closedf = true;
    end;
  end;
  
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (true) then begin  //Retp.UpdStockFlag!=0
      location = Retrw.Location;
      if (blank(location)) then begin
        location = Retp.Location;
      end;
      if (blank(location)) then begin
        location = MSb.MainStock;
      end;
      if (removef) then begin
        qty = -Retrw.Quant;
      end else begin
        qty = Retrw.Quant;
      end;
//      if (ShouldItemUpdateStock(Retrw.ArtCode)==false) then begin
//in case of return goods we cannot use it, it returns true for structured items as well
//which is wrong, we should allow structure items on ret goods(to update order)
//and return stocked items from recepy
      if (ReadFirstItem(Retrw.ArtCode,INr,false,false)) then begin
      end;      
      if (INr.ItemType!=1) and (INr.ItemType!=2) then begin
        qty = blankval;
      end else begin
        isstruct = ExpandStructItem(Retrw.ArtCode,Retrw.Recepy,Retrw.Quant,RecSHr);
        if (isstruct==false) then begin
          if (Retp.Type==0) then begin
            orq = qty;
          end else begin
            if (rebuildstockf) then begin
              orq = qty;
            end else begin
              orq = blankval;
            end;
          end;
          if (MSb.UnitConvCalc==0) then begin
            q2 = qty*Retrw.Coefficient;
          end else begin
            q2 = qty/Retrw.Coefficient;
          end;
          if (Retp.UpdStockFlag!=0) then begin
            UpdateInstock("RetVc",Retp.SerNr,Retrw.ArtCode,location,Retp.TransDate,qty,t,t,t,t,q2,t,t,t);
          end;
          if (orfound) then begin
            GetLocationFromOrder(ORr,Retrw.OrdRow,MSb.MainStock,ordlocation,qty,ordqty);
            if (Retp.Type==0) then begin
              if (ORr.Closed==0) then begin
              if (ORr.Reserved!=0) then begin
                rsrved = orq;
              end;
              end;
            end;
            if (Importing==false) then begin // We shouldn't check settings for this, it should be stored on the record.
              if (MSb.UpdateAvailable!=0) then begin
//                if (qty==0) then begin orq = 0; end; // So, if you have deliveredd what you have ordered, make sure that ordered qty is zero.... makes NO sense...
                if (qty<0) then begin
                  orq = orq + qty;
                  if (orq<0) then begin orq = 0; end;
                end;
              end;
            end;
           // UpdateInstock("RetVc",Retp.SerNr,Retrw.ArtCode,ordlocation,Retp.TransDate,t,orq,rsrved,t,t,t,t,t,t);
            UpdateInstock("RetVc",Retp.SerNr,Retrw.ArtCode,ordlocation,Retp.TransDate,t,orq,0,t,t,t,t,t,t);// Edit ************************** Monday, 29 November 2010 10:29:37
          end;
        end else begin
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,RecSHrw);
            if (removef) then begin
              qty = -RecSHrw.Ship;
            end else begin
              qty = RecSHrw.Ship;
            end;
            if (Retp.Type==0) then begin
              orq = qty;
            end else begin
              orq = blankval;
            end;
            if (closedf) then begin
              orq = blankval;
            end;
            if (MSb.UnitConvCalc==0) then begin
              q2 = qty*RecSHrw.Coefficient;
            end else begin
              q2 = qty/RecSHrw.Coefficient;
            end;
            if (Retp.UpdStockFlag!=0) then begin
              UpdateInstock("RetVc",Retp.SerNr,RecSHrw.ArtCode,location,Retp.TransDate,qty,t,t,t,t,q2,t,t,t);
            end;
            if (orfound) then begin
              GetLocationFromOrder(ORr,Retrw.OrdRow,MSb.MainStock,ordlocation,tmp,ordqty);
              UpdateInstock("RetVc",Retp.SerNr,RecSHrw.ArtCode,ordlocation,Retp.TransDate,t,qty,t,t,t,q2,t,t,t);
            end;
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

